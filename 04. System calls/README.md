
# 4. System calls
System calls are an important resource when building programs on userland, using such calls, we are able to interact with the Operating System, asking it to perform operations that only the kernel can accomplish. The most common requested operations from the OS include printing a string on screen, getting the current directory, reading a file and so on.

Keeping that in mind, a great part of the C language functions are performed by the Operating System, and not by the language itself. A program on userland doesn't have the privileges to access the Hard Disk to read a file or even access the network card to send network packets. Userland programs barely know how to perform such operations, the number of instructions generated by the compiler isn't enough to control an entire device but is enough to instruct the OS to accomplish the necessary tasks.

A system call uses registers to communicate with the OS; also employing1 a new opcode called 'syscall'.

The code below is a program written in Assembly that prints the "Hello, world!" message:

```asm
; As mentioned before, the text segment is used to
; store the program instructions, so is within this 
; segment that we are going to write the Assembly code

; The global keyword is used to make a symbol available
; across all object files. The linker requires that the
; main text symbol be visible using this statement.
global _start

segment .text

; By default, the _start is the entry point of the program.
_start:

    ; The following block of code will print a
    ; message on terminal.
    ;
    ; The rax register means the operation to be performed, 
    ; the programmers that built the linux made 
    ; the value 1 represent "print something...".
    ;
    ; The rdi register is the file descriptor to where the print
    ; shall be redirected, '0' represents the STDIN,
    ; '1' the STDOUT, and '2' the STDERR.
    ;
    ; The rsi register is the pointer to the 
    ; message.
    ;
    ; The rdx register is the message length

    mov rax, 1
    mov rdi, 1
    mov rsi, message
    mov rdx, message_size

    ; After setting the registers with the
    ; correct values, ask the OS to perform the
    ; task
    syscall

    ; Our program finished all its instructions,
    ; so we need to ask the OS to unload the
    ; program from memory    
    ;
    ; 60 is the exit syscall
    ; 0 is the exit status

    mov rax, 60
    mov rdi, 0

    ; Asking the OS to perform the task
    syscall

; The read-only data segment is the place
; where we define the 'Hello, world!' message.
segment .rodata

    ; We use 'db' to Define a Byte or a chain of bytes.
    ; Every comma outside the quotes is a 
    ; concatenation, so the value 0xa, that means '\n'
    ; is appended to the string.
    ;
    ; The 0x0 represents the null 
    ; character, that is always necessary when we
    ; are handling with strings

    message db 'Hello, world!', 0xa, 0x0

    ; 'equ $-' means to get the size of a 
    ; constant, so message_size = sizeof(message)
    message_size equ $- message
```

At this moment, you might ask: "Is really necessary remember every single system call number when i need to use them to accomplish a task?". The answer is no. The Linux kernel developers already provide a list of all system calls, which can be found anywhere on the internet, but i would recommend this one: https://hackeradam.com/x86-64-linux-syscalls/.

## 1.1. Warnings
When you issue a system call, a significant number of registers are wiped out, so you must save their values in memory if you want to use them later.


## 1.2. Running the code

In order to run this code on your own machine, you will need the Nasm assembler. Although Nasm is available for other platforms, such as Windows, this code is designed to run exclusively on Linux systems due to the system calls being imcompatible on both platforms.

Assuming that your source file is called "hello_world.asm", use the following command to assemble:
```sh
nasm -f elf64 hello_world.asm
```
To link the object file do:
```sh
ld hello_world.o -o hello_world
```
and simply call the program:
```sh
./hello_world
```

## 1.3. Changing the entry point name
As mentioned before in the comments of the previous example, the linker will use the _start symbol as the default program entry point. However, this is a customizable feature, and you can set the entry point to any symbol. The linker defines the entry point by the value provided to the -e flag.
```asm
segment .text
global customized_program_entry_point

customized_program_entry_point:
    mov rax, 1
    mov rdi, 1
    mov rsi, msg
    mov rdx, msg.sz
    syscall

    mov rax, 60
    mov rdi, 0
    syscall

segment .rodata
    msg db 'Hello, world!', 0xa, 0x0
    msg.sz equ $-msg
```
Commands to assemble and link the source file:
```sh
nasm -f elf64 entry_point.asm
ld -e customized_program_entry_point entry_point.o -o entry_point
```
Running the program should give us the expected result:
```txt
sh-5.1$ ./entry_point 
Hello, world!
```